```assembly
  _____       _                 _            _   _             
  \_   \_ __ | |_ _ __ ___   __| |_   _  ___| |_(_) ___  _ __  
   / /\/  _ \| __|  __/ _ \ / _` | | | |/ __| __| |/ _ \| '_ \ 
/\/ /_ | | | | |_| | | (_) | (_| | |_| | (__| |_| | (_) | | | |
\____/ |_| |_|\__|_|  \___/ \__,_|\__,_|\___|\__|_|\___/|_| |_|
                                                               
```


## What is binary exploitation?
```assembly
-->breaking the boundaries on a compiled application
```
## What is the point?
```assembly
-->get information off the machine 
-->execute arbitrary code
-->escalate to a higher privileged user
```

## Memory
### Memory layout of C program
```assembly
   high address ______________________
                |                    |      command-line arguments
                |                    |      and environment variables
                |____________________|
                |       stack        |
                |--------------------|      grows downward
                |         |          |
                |         V          |
                |                    |
                |                    |
                |                    |
                |                    |
                |         Λ          |
                |         |          |
                |--------------------|      grows upwards
                |        heap        |
                |____________________|
                | uninitialized data |      initialized to 0
                |       (bss)        |      by exec
                |____________________|
                |  initialized data  |
                |____________________|      read from 
                |                    |      program file
                |        text        |      by exec
    low adress  |____________________|
                
    stack --> place where all the function parameters, return addresses
              and the local variables of the function are stored

    heap --> all the dynamically allocated memory resides here. (malloc)

```

## Registers

``` Registers are small, fast storage units inside the CPU that hold data and instructions needed for processing. ```
```assembly
+----------------+---------------+---------------+-------------+
| 64-bit register| Lower 32 bits | Lower 16 bits | Lower 8 bits|
+----------------+---------------+---------------+-------------+
| rax            | eax           | ax            | al          |
| rbx            | ebx           | bx            | bl          |
| rcx            | ecx           | cx            | cl          |
| rdx            | edx           | dx            | dl          |
| rsi            | esi           | si            | sil         |
| rdi            | edi           | di            | dil         |
| rbp            | ebp           | bp            | bpl         |
| rsp            | esp           | sp            | spl         |
| r8             | r8d           | r8w           | r8b         |
| r9             | r9d           | r9w           | r9b         |
| r10            | r10d          | r10w          | r10b        |
| r11            | r11d          | r11w          | r11b        |
| r12            | r12d          | r12w          | r12b        |
| r13            | r13d          | r13w          | r13b        |
| r14            | r14d          | r14w          | r14b        |
| r15            | r15d          | r15w          | r15b        |
+----------------+---------------+---------------+-------------+
```

```assembly
    The structure of a register
+----------------------------------+
|               |        | ah | al |    --> 8 bits eatch
+----------------------------------+
                         |____ax___|    --> 16 bits
                |_______eax________|    --> 32 bits
|______________rax_________________|    --> 64 bits
```
```assembly
                            Common Registers

--> %rip – instruction pointer registers
    • it stores the address of the next instruction to be executed
--> %rsp – stack pointer register
    • it stores the address of the top of the stack.
--> %rbp – base pointer register
    • keeps tab of function parameters and local variables
```

## How does code execute?

```Machine code is a low-level programming language consisting of binary instructions that a computer's CPU can execute directly.```

```assembly
+----------------------------+
| 55 48 89 e5 48 8d 05 ac 0e |      Machine code instructions 
| 00 00 48 89 c7 e8 f0 fe ff |      (x64) that print “Hello, word!"
| ff b8 00 00 00 00 5d c3    |      to standard output.
+----------------------------+
```
### Now a good question is "Where the machine code comes from?"

```assembly
                          From C code to execution

This is what processor execute                   The same but human readable
   +----------------------+                      +------------------------+
   | 55                   |    Instructions in   | push rbp               |
   | 48 89 e5             |    x64 assembly      | mov rbp, rsp           |
   | 48 8d 05 ac 0e 00 00 |    //          \\    | lea rax, [rip+0xeac]   |
   | 48 89 c7             |   //============\\   | mov rdi, rax           |
   | e8 f0 fe ff ff       |   \\============//   | call 1050 <puts@plt>   |
   | b8 00 00 00 00       |    \\          //    | mov eax, 0x0           |
   | 5d                   |    that print        | pop rbp                |
   | c3                   |    “Hello, world!”   | ret                    |
   +----------------------+    to the console    +------------------------+


  +------------------------+
  | push rbp               |
  | mov rbp, rsp           |      Compiling     +---------------------------+
  | lea rax, [rip+0xeac]   |   //               | int main(){               |
  | mov rdi, rax           |  //==============  |     puts("Hello, world!");|
  | call 1050 <puts@plt>   |  \\==============  |     return 0;             |
  | mov eax, 0x0           |   \\               | }                         |
  | pop rbp                |      process       +---------------------------+
  | ret                    |
  +------------------------+

```

```assembly
            ┌───────────────────────────────────────────────┐
            │ int main() {                                  │
            │     puts("Hello, world!");                    │
            │     return 0;                                 │
            │ }                                             │
            └───────────────────────────────────────────────┘
                                    │
                                 Compile
                                    │
                                    ▼
            ┌───────────────────────────────────────────────┐
            │ push rbp                                      │
            │ mov rbp, rsp                                  │
            │ lea rax, [rip+0xeac]                          │
            │ mov rdi, rax                                  │
            │ call 1050 <puts@plt>                          │
            │ mov eax, 0x0                                  │
            │ pop rbp                                       │
            │ ret                                           │
            └───────────────────────────────────────────────┘
                                    │
                                 Assemble
                                    │
                                    ▼
            ┌─────────────────────────────────────────────────┐
            │ 55 48 89 e5 48 8d 05 ac 0e 00 00 48 89 c7 e8... │
            └─────────────────────────────────────────────────┘
                                    │
                                   Link
                                    │
                                    ▼
            ┌─────────────────────────────────────────────────┐
            │ 55 48 89 ...                                    │
            │ libc                                            │
            └─────────────────────────────────────────────────┘
                                    │
                                   Run
                                    │
                                    ▼
                           ┌──────────────────┐
                           │       CPU        │
                           └──────────────────┘
                                    │
                                    ▼
                             "Hello, world!"
```
## Calling Conventions
In Linux binaries, there are really only two commonly used calling conventions:
```assembly
cdecl: for 32-bit binaries
SysV : for 64-bit binaries
```

### cdecl
The cdecl (which stands for C declaration) is a calling convention for the C programming language and is used by many C compilers for the x86 architecture.In cdecl:
```assembly
subroutine args: are passed on the stack.
Int values & memory adrs: are returned in the EAX register.
floating point values: in the ST0 x87 register.

Registers EAX,ECX,EDX: are caller-saved
The rest: are callee-saved.

- The x87 floating point registers ST0 to ST7 must be empty (popped or freed) when calling a new function
- ST1 to ST7 must be empty on exiting a function.
- ST0 must also be empty when not used for returning a value.
```

### SysV
The calling convention of the System V AMD64 ABI is followed on Solaris, Linux, FreeBSD, macOS and is the de facto standard among Unix and Unix-like operating systems. For 64-bit binaries,the 6 function arguments are first passed in certain registers:
```assembly

Integer/Pointer Arguments 1-6:	RDI, RSI, RDX, RCX, R8, R9
Floating Point Arguments 1-8:   XMM0 - XMM7
Excess Arguments:               Stack
Static chain pointer:	        R10
```
then any leftover arguments are pushed onto the stack in reverse order, as in cdecl.

## GOT
The Global Offset Table (or GOT) is a section inside of programs that: holds addresses of functions that are dynamically linked.

Most programs do not include every function they use within their own binaries. Instead, they rely on "linking" to shared libraries, such as the standard C library (libc). This approach minimizes binary size by allowing common functions to be stored once on disk and shared across multiple programs.

Unless a program is configured with full RELRO (Read-Only Relocation), the process of linking functions to their actual addresses in a dynamic library is performed lazily. While all required dynamic libraries are loaded into memory at the program's startup, the actual mapping of functions to their respective code addresses occurs only when the function is called for the first time. For example, in the following C code snippet, the address of the `puts` function from libc will not be resolved until the function is invoked for the first time:

```c
int main(){
    puts("rootpwn loves yall");
    puts("even though u have an antivirus");
    return 0;
}
```

To speed up function calls, the Global Offset Table (GOT) caches the result of the initial lookup, letting future calls go directly to the function without using the dynamic resolver.  

Key points:  
- The GOT holds pointers to libraries affected by ASLR.  
- The GOT is writable, which is useful for Return-Oriented Programming (ROP).  

**PLT (Procedure Linkage Table)**  
Before a function's address is resolved, the GOT points to a stub in the Procedure Linkage Table (PLT), which calls the dynamic linker to resolve the function’s address.